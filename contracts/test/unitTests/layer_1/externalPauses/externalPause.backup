// contracts/test/unitTests/layer_1/externalPauses/externalPause.test.ts
import { expect } from 'chai'
import { ethers } from 'hardhat'
import { SignerWithAddress } from '@nomiclabs/hardhat-ethers/signers.js'
import { isinGenerator } from '@thomaschaplin/isin-generator'
import {
    BusinessLogicResolver,
    ExternalPauseManagement,
    ExternalPauseManagement__factory,
    IFactory,
    MockedExternalPause,
    MockedExternalPause__factory,
    ResolverProxy,
    AccessControlFacet__factory,
    IExternalPauseManagement__factory,
} from '@typechain'
import {
    deployAtsFullInfrastructure,
    DeployAtsFullInfrastructureCommand,
    deployEquityFromFactory,
    GAS_LIMIT,
    MAX_UINT256,
    PAUSE_MANAGER_ROLE,
    RegulationSubType,
    RegulationType,
} from '@scripts'

const PAUSE_MANAGEMENT_RESOLVER_KEY =
    '0xadd2e196c17b4f607e327e46341eedbbbc3dce86ac90ceb3e7244b0a5f8590ac'

describe('ExternalPause Tests', () => {
    let signer_A: SignerWithAddress
    let signer_B: SignerWithAddress
    let account_A: string
    let account_B: string

    let diamond: ResolverProxy
    let factory: IFactory
    let businessLogicResolver: BusinessLogicResolver
    let externalPauseManagement: ExternalPauseManagement
    let externalPauseMock1: MockedExternalPause
    let externalPauseMock2: MockedExternalPause
    let externalPauseMock3: MockedExternalPause // Added for more complex scenarios

    before(async () => {
        // mute | mock console.log
        console.log = () => {}
        ;[signer_A, signer_B] = await ethers.getSigners()
        account_A = signer_A.address
        account_B = signer_B.address

        const { ...deployedContracts } = await deployAtsFullInfrastructure(
            await DeployAtsFullInfrastructureCommand.newInstance({
                signer: signer_A,
                useDeployed: false,
                useEnvironment: false,
                timeTravelEnabled: true,
            })
        )

        factory = deployedContracts.factory.contract
        businessLogicResolver = deployedContracts.businessLogicResolver.contract

        // Deploy mock contracts for external pauses ONCE
        externalPauseMock1 = await new MockedExternalPause__factory(
            signer_A
        ).deploy()
        await externalPauseMock1.deployed()

        externalPauseMock2 = await new MockedExternalPause__factory(
            signer_A
        ).deploy()
        await externalPauseMock2.deployed()

        externalPauseMock3 = await new MockedExternalPause__factory(
            signer_A
        ).deploy()
        await externalPauseMock3.deployed()
    })

    beforeEach(async () => {
        // Deploy a fresh diamond proxy (implicitly initialized)
        diamond = await deployEquityFromFactory({
            adminAccount: account_A,
            isWhiteList: false,
            isControllable: true,
            arePartitionsProtected: false,
            clearingActive: false,
            isMultiPartition: false,
            name: 'TEST_ExternalPause',
            symbol: 'TEP',
            decimals: 6,
            isin: isinGenerator(),
            votingRight: false,
            informationRight: false,
            liquidationRight: false,
            subscriptionRight: true,
            conversionRight: true,
            redemptionRight: true,
            putRight: false,
            dividendRight: 1,
            currency: '0x345678',
            numberOfShares: MAX_UINT256,
            nominalValue: 100,
            regulationType: RegulationType.REG_S,
            regulationSubType: RegulationSubType.NONE,
            countriesControlListType: true,
            listOfCountries: 'ES,FR,CH',
            info: 'nothing',
            factory: factory,
            businessLogicResolver: businessLogicResolver.address,
        })

        externalPauseManagement = ExternalPauseManagement__factory.connect(
            diamond.address,
            signer_A
        )

        // Grant PAUSE_MANAGER_ROLE to signer_A
        const accessControlFacet = AccessControlFacet__factory.connect(
            diamond.address,
            signer_A
        )
        await accessControlFacet.grantRole(PAUSE_MANAGER_ROLE, account_A)

        // Add the default pauses needed for most tests using addExternalPause
        // Assumes deployment initializes the list as empty.
        try {
            // Ensure mocks are not already present if deployEquityFromFactory adds defaults
            if (
                !(await externalPauseManagement.isExternalPause(
                    externalPauseMock1.address
                ))
            ) {
                await externalPauseManagement.addExternalPause(
                    externalPauseMock1.address,
                    { gasLimit: GAS_LIMIT.default }
                )
            }
            if (
                !(await externalPauseManagement.isExternalPause(
                    externalPauseMock2.address
                ))
            ) {
                await externalPauseManagement.addExternalPause(
                    externalPauseMock2.address,
                    { gasLimit: GAS_LIMIT.default }
                )
            }
            // Ensure mock3 is not present at start of tests
            if (
                await externalPauseManagement.isExternalPause(
                    externalPauseMock3.address
                )
            ) {
                await externalPauseManagement.removeExternalPause(
                    externalPauseMock3.address
                )
            }
        } catch (e: unknown) {
            console.error('Error setting up default pauses in beforeEach:', e)
            throw e // Re-throw unexpected errors during setup
        }

        // Ensure mocks are unpaused by default for most tests
        await externalPauseMock1.setPaused(false, {
            gasLimit: GAS_LIMIT.default,
        })
        await externalPauseMock2.setPaused(false, {
            gasLimit: GAS_LIMIT.default,
        })
        await externalPauseMock3.setPaused(false, {
            gasLimit: GAS_LIMIT.default,
        })
    })

    // --- Add Tests ---
    it('GIVEN an unlisted external pause WHEN added THEN it is listed and event is emitted', async () => {
        const newPause = externalPauseMock3.address // Use the 3rd mock
        // Ensure it's not already listed (double check beforeEach logic)
        expect(await externalPauseManagement.isExternalPause(newPause)).to.be
            .false

        const initialCount =
            await externalPauseManagement.getExternalPausesCount()

        await expect(
            externalPauseManagement.addExternalPause(newPause, {
                gasLimit: GAS_LIMIT.default,
            })
        )
            .to.emit(externalPauseManagement, 'AddedToExternalPauses')
            .withArgs(signer_A.address, newPause)

        expect(await externalPauseManagement.isExternalPause(newPause)).to.be
            .true
        expect(await externalPauseManagement.getExternalPausesCount()).to.equal(
            initialCount.add(1)
        )
    })

    it('GIVEN a listed external pause WHEN adding it again THEN it reverts with ListedPause', async () => {
        // externalPauseMock1 should have been added during beforeEach
        expect(
            await externalPauseManagement.isExternalPause(
                externalPauseMock1.address
            )
        ).to.be.true // Verify prerequisite
        await expect(
            externalPauseManagement.addExternalPause(
                externalPauseMock1.address,
                { gasLimit: GAS_LIMIT.default }
            )
        ).to.be.revertedWithCustomError(externalPauseManagement, 'ListedPause')
    })

    // --- Remove Tests ---
    it('GIVEN a listed external pause WHEN removed THEN it is unlisted and event is emitted', async () => {
        const pauseToRemove = externalPauseMock1.address
        // Ensure it's listed (added in beforeEach)
        expect(await externalPauseManagement.isExternalPause(pauseToRemove)).to
            .be.true // Verify prerequisite

        const initialCount =
            await externalPauseManagement.getExternalPausesCount()

        await expect(
            externalPauseManagement.removeExternalPause(pauseToRemove, {
                gasLimit: GAS_LIMIT.default,
            })
        )
            .to.emit(externalPauseManagement, 'RemovedFromExternalPauses')
            .withArgs(signer_A.address, pauseToRemove)

        expect(await externalPauseManagement.isExternalPause(pauseToRemove)).to
            .be.false
        expect(await externalPauseManagement.getExternalPausesCount()).to.equal(
            initialCount.sub(1)
        )
    })

    it('GIVEN an unlisted external pause WHEN removing THEN it reverts with UnlistedPause', async () => {
        const randomAddress = ethers.Wallet.createRandom().address
        expect(await externalPauseManagement.isExternalPause(randomAddress)).to
            .be.false // Verify prerequisite

        await expect(
            externalPauseManagement.removeExternalPause(randomAddress, {
                gasLimit: GAS_LIMIT.default,
            })
        ).to.be.revertedWithCustomError(
            externalPauseManagement,
            'UnlistedPause'
        )
    })

    // --- Update Tests ---
    // Note: These tests assume mock1 and mock2 are added in beforeEach.
    it('GIVEN multiple external pauses WHEN updated THEN their statuses are updated and event is emitted', async () => {
        // Initial state assumed: mock1=true, mock2=true. Verify it.
        expect(
            await externalPauseManagement.isExternalPause(
                externalPauseMock1.address
            )
        ).to.be.true
        expect(
            await externalPauseManagement.isExternalPause(
                externalPauseMock2.address
            )
        ).to.be.true
        expect(
            await externalPauseManagement.isExternalPause(
                externalPauseMock3.address
            )
        ).to.be.false
        const initialCount =
            await externalPauseManagement.getExternalPausesCount()
        expect(initialCount).to.equal(2)

        const pauses = [
            externalPauseMock1.address, // Keep (no change)
            externalPauseMock2.address, // Remove
            externalPauseMock3.address, // Add
        ]
        const actives = [true, false, true]

        await expect(
            externalPauseManagement.updateExternalPauses(pauses, actives, {
                gasLimit: GAS_LIMIT.high,
            })
        )
            .to.emit(externalPauseManagement, 'ExternalPausesUpdated')
            .withArgs(signer_A.address, pauses, actives)

        expect(await externalPauseManagement.isExternalPause(pauses[0])).to.be
            .true // mock1 still active
        expect(await externalPauseManagement.isExternalPause(pauses[1])).to.be
            .false // mock2 removed
        expect(await externalPauseManagement.isExternalPause(pauses[2])).to.be
            .true // mock3 added
        expect(await externalPauseManagement.getExternalPausesCount()).to.equal(
            initialCount.sub(1).add(1)
        ) // 2 - 1 + 1 = 2
    })

    it('GIVEN update data with contradictions WHEN updated THEN it reverts with UpdateExternalPausesContradiction (add existing)', async () => {
        // Initial state assumed: mock1=true, mock2=true
        const pauses = [externalPauseMock1.address, externalPauseMock2.address]
        const actives = [true, true] // Try to re-add mock1 and mock2

        await expect(
            externalPauseManagement.updateExternalPauses(pauses, actives, {
                gasLimit: GAS_LIMIT.high,
            })
        )
            .to.be.revertedWithCustomError(
                externalPauseManagement,
                'UpdateExternalPausesContradiction'
            )
            .withArgs(pauses, actives, externalPauseMock1.address)
    })

    it('GIVEN update data with contradictions WHEN updated THEN it reverts with UpdateExternalPausesContradiction (remove non-existing)', async () => {
        // Initial state assumed: mock1=true, mock2=true
        const nonExistentPause = ethers.Wallet.createRandom().address
        const pauses = [nonExistentPause]
        const actives = [false] // Try to remove a non-existent pause

        await expect(
            externalPauseManagement.updateExternalPauses(pauses, actives, {
                gasLimit: GAS_LIMIT.high,
            })
        )
            .to.be.revertedWithCustomError(
                externalPauseManagement,
                'UpdateExternalPausesContradiction'
            )
            .withArgs(pauses, actives, nonExistentPause)
    })

    it('GIVEN update data with no actual changes WHEN updating THEN it reverts with ExternalPausesNotUpdated', async () => {
        // Initial state assumed: mock1=true, mock2=true
        // First test the case where the contradiction revert happens first
        const pauses1 = [externalPauseMock1.address, externalPauseMock2.address]
        const actives1 = [true, true] // Try setting both to true (no change)
        await expect(
            externalPauseManagement.updateExternalPauses(pauses1, actives1, {
                gasLimit: GAS_LIMIT.high,
            })
        )
            .to.be.revertedWithCustomError(
                externalPauseManagement,
                'UpdateExternalPausesContradiction' // This hits first because _add returns false
            )
            .withArgs(pauses1, actives1, externalPauseMock1.address)

        // Now, test ExternalPausesNotUpdated properly:
        // Remove mock1, then try to update by *removing* mock1 again (which returns false but doesn't revert internally)
        // and *keeping* mock2 (which also returns false). Since no internal operation returns true, should revert.
        await externalPauseManagement.removeExternalPause(
            externalPauseMock1.address
        ) // State: mock2=true
        expect(
            await externalPauseManagement.isExternalPause(
                externalPauseMock1.address
            )
        ).to.be.false
        expect(
            await externalPauseManagement.isExternalPause(
                externalPauseMock2.address
            )
        ).to.be.true

        const updatePauses = [
            externalPauseMock1.address,
            externalPauseMock2.address,
        ]
        const updateActives = [false, true] // Try removing removed mock1, keeping existing mock2

        await expect(
            externalPauseManagement.updateExternalPauses(
                updatePauses,
                updateActives,
                { gasLimit: GAS_LIMIT.high }
            )
        )
            .to.be.revertedWithCustomError(
                externalPauseManagement,
                'ExternalPausesNotUpdated' // Now this should hit
            )
            .withArgs(updatePauses, updateActives)
    })

    it('GIVEN empty arrays WHEN updating THEN it succeeds and emits event', async () => {
        const initialCount =
            await externalPauseManagement.getExternalPausesCount()
        const pauses: string[] = []
        const actives: boolean[] = []

        await expect(
            externalPauseManagement.updateExternalPauses(pauses, actives, {
                gasLimit: GAS_LIMIT.high,
            })
        )
            .to.emit(externalPauseManagement, 'ExternalPausesUpdated')
            .withArgs(signer_A.address, pauses, actives)

        // Count should remain unchanged
        expect(await externalPauseManagement.getExternalPausesCount()).to.equal(
            initialCount
        )
    })

    // --- View/Getter Functions ---
    it('GIVEN listed and unlisted addresses WHEN isExternalPause is called THEN it returns the correct status', async () => {
        // mock1, mock2 added in beforeEach
        expect(
            await externalPauseManagement.isExternalPause(
                externalPauseMock1.address
            )
        ).to.be.true
        expect(
            await externalPauseManagement.isExternalPause(
                externalPauseMock2.address
            )
        ).to.be.true

        const randomAddress = ethers.Wallet.createRandom().address
        expect(await externalPauseManagement.isExternalPause(randomAddress)).to
            .be.false

        // Add mock3 and check
        await externalPauseManagement.addExternalPause(
            externalPauseMock3.address
        )
        expect(
            await externalPauseManagement.isExternalPause(
                externalPauseMock3.address
            )
        ).to.be.true
    })

    it('GIVEN external pauses WHEN getExternalPausesCount is called THEN it returns the current count', async () => {
        const initialCount =
            await externalPauseManagement.getExternalPausesCount() // Should be 2 from beforeEach setup
        expect(initialCount).to.equal(2)

        // Add one
        await externalPauseManagement.addExternalPause(
            externalPauseMock3.address
        )
        expect(await externalPauseManagement.getExternalPausesCount()).to.equal(
            initialCount.add(1)
        ) // 3

        // Remove one (mock1)
        await externalPauseManagement.removeExternalPause(
            externalPauseMock1.address
        )
        expect(await externalPauseManagement.getExternalPausesCount()).to.equal(
            initialCount
        ) // 2

        // Remove remaining (mock2, mock3)
        await externalPauseManagement.removeExternalPause(
            externalPauseMock2.address
        )
        await externalPauseManagement.removeExternalPause(
            externalPauseMock3.address
        )
        expect(await externalPauseManagement.getExternalPausesCount()).to.equal(
            0
        )
    })

    it('GIVEN external pauses WHEN getExternalPausesMembers is called THEN it returns paginated members', async () => {
        // Assumed state: mock1, mock2. Verified in beforeEach setup.
        expect(await externalPauseManagement.getExternalPausesCount()).to.equal(
            2
        )

        let membersPage =
            await externalPauseManagement.getExternalPausesMembers(0, 1)
        expect(membersPage).to.have.lengthOf(1)
        expect([
            externalPauseMock1.address,
            externalPauseMock2.address,
        ]).to.include(membersPage[0])

        membersPage = await externalPauseManagement.getExternalPausesMembers(
            1,
            1
        )
        expect(membersPage).to.have.lengthOf(1)
        expect([
            externalPauseMock1.address,
            externalPauseMock2.address,
        ]).to.include(membersPage[0])
        expect(membersPage[0]).to.not.equal(
            (await externalPauseManagement.getExternalPausesMembers(0, 1))[0]
        ) // Ensure pages differ

        let allMembers = await externalPauseManagement.getExternalPausesMembers(
            0,
            2
        )
        expect(allMembers).to.have.lengthOf(2)
        expect(allMembers).to.contain(externalPauseMock1.address)
        expect(allMembers).to.contain(externalPauseMock2.address)

        // Add mock3
        await externalPauseManagement.addExternalPause(
            externalPauseMock3.address
        )
        allMembers = await externalPauseManagement.getExternalPausesMembers(
            0,
            3
        )
        expect(allMembers).to.have.lengthOf(3)
        expect(allMembers).to.contain(externalPauseMock1.address)
        expect(allMembers).to.contain(externalPauseMock2.address)
        expect(allMembers).to.contain(externalPauseMock3.address)

        // Test pagination edge cases
        membersPage = await externalPauseManagement.getExternalPausesMembers(
            1,
            2
        ) // Page 2 (index 1), size 2 -> should return 1 element
        expect(membersPage).to.have.lengthOf(1)

        membersPage = await externalPauseManagement.getExternalPausesMembers(
            3,
            1
        ) // Page 4 (index 3)
        expect(membersPage).to.have.lengthOf(0)

        // Empty list
        await externalPauseManagement.removeExternalPause(
            externalPauseMock1.address
        )
        await externalPauseManagement.removeExternalPause(
            externalPauseMock2.address
        )
        await externalPauseManagement.removeExternalPause(
            externalPauseMock3.address
        )
        allMembers = await externalPauseManagement.getExternalPausesMembers(
            0,
            5
        )
        expect(allMembers).to.have.lengthOf(0)
    })

    // --- Pause Modifier Tests (onlyUnpaused) ---
    it('GIVEN an external pause is paused WHEN calling a function with onlyUnpaused THEN it reverts with TokenIsPaused', async () => {
        await externalPauseMock1.setPaused(true, {
            gasLimit: GAS_LIMIT.default,
        }) // Pause mock1

        await expect(
            externalPauseManagement.addExternalPause(
                externalPauseMock3.address,
                { gasLimit: GAS_LIMIT.default }
            )
        ).to.be.reverted

        await expect(
            externalPauseManagement.removeExternalPause(
                externalPauseMock2.address,
                { gasLimit: GAS_LIMIT.default }
            )
        ).to.be.reverted

        const pauses = [externalPauseMock2.address]
        const actives = [false]
        await expect(
            externalPauseManagement.updateExternalPauses(pauses, actives, {
                gasLimit: GAS_LIMIT.high,
            })
        ).to.be.reverted
    })

    it('GIVEN all external pauses are unpaused WHEN calling a function with onlyUnpaused THEN it succeeds', async () => {
        // Verify mocks are unpaused (set in beforeEach)
        expect(await externalPauseMock1.isPaused()).to.be.false
        expect(await externalPauseMock2.isPaused()).to.be.false

        // Add should succeed
        await expect(
            externalPauseManagement.addExternalPause(
                externalPauseMock3.address,
                { gasLimit: GAS_LIMIT.default }
            )
        ).to.not.be.reverted

        // Remove should succeed
        await expect(
            externalPauseManagement.removeExternalPause(
                externalPauseMock1.address,
                { gasLimit: GAS_LIMIT.default }
            )
        ).to.not.be.reverted

        // Update should succeed
        const pauses = [externalPauseMock2.address] // mock2 exists, mock1 removed above, mock3 added above
        const actives = [false] // remove mock2
        await expect(
            externalPauseManagement.updateExternalPauses(pauses, actives, {
                gasLimit: GAS_LIMIT.high,
            })
        ).to.not.be.reverted
    })

    // --- Access Control Tests ---
    it('GIVEN an account without PAUSE_MANAGER_ROLE WHEN adding an external pause THEN it reverts with AccessControl', async () => {
        const newPause = externalPauseMock3.address
        await expect(
            externalPauseManagement
                .connect(signer_B)
                .addExternalPause(newPause, { gasLimit: GAS_LIMIT.default })
        ).to.be.revertedWith(
            `AccessControl: account ${account_B.toLowerCase()} is missing role ${PAUSE_MANAGER_ROLE}`
        )
    })

    it('GIVEN an account with PAUSE_MANAGER_ROLE WHEN adding an external pause THEN it succeeds', async () => {
        const newPause = externalPauseMock3.address
        // Ensure pause isn't already there (checked in beforeEach)
        expect(await externalPauseManagement.isExternalPause(newPause)).to.be
            .false
        await expect(
            externalPauseManagement.addExternalPause(newPause, {
                gasLimit: GAS_LIMIT.default,
            })
        )
            .to.emit(externalPauseManagement, 'AddedToExternalPauses')
            .withArgs(account_A, newPause)
        expect(await externalPauseManagement.isExternalPause(newPause)).to.be
            .true
    })

    it('GIVEN an account without PAUSE_MANAGER_ROLE WHEN removing an external pause THEN it reverts with AccessControl', async () => {
        // Ensure pause is there to remove (added in beforeEach)
        expect(
            await externalPauseManagement.isExternalPause(
                externalPauseMock1.address
            )
        ).to.be.true
        await expect(
            externalPauseManagement
                .connect(signer_B)
                .removeExternalPause(externalPauseMock1.address, {
                    gasLimit: GAS_LIMIT.default,
                })
        ).to.be.revertedWith(
            `AccessControl: account ${account_B.toLowerCase()} is missing role ${PAUSE_MANAGER_ROLE}`
        )
    })

    it('GIVEN an account with PAUSE_MANAGER_ROLE WHEN removing an external pause THEN it succeeds', async () => {
        // Ensure pause is there to remove
        expect(
            await externalPauseManagement.isExternalPause(
                externalPauseMock1.address
            )
        ).to.be.true
        await expect(
            externalPauseManagement.removeExternalPause(
                externalPauseMock1.address,
                { gasLimit: GAS_LIMIT.default }
            )
        )
            .to.emit(externalPauseManagement, 'RemovedFromExternalPauses')
            .withArgs(account_A, externalPauseMock1.address)
        expect(
            await externalPauseManagement.isExternalPause(
                externalPauseMock1.address
            )
        ).to.be.false
    })

    it('GIVEN an account without PAUSE_MANAGER_ROLE WHEN updating external pauses THEN it reverts with AccessControl', async () => {
        const pauses = [externalPauseMock1.address]
        const actives = [false] // Try to remove mock1
        // Ensure mock1 exists
        expect(
            await externalPauseManagement.isExternalPause(
                externalPauseMock1.address
            )
        ).to.be.true
        await expect(
            externalPauseManagement
                .connect(signer_B)
                .updateExternalPauses(pauses, actives, {
                    gasLimit: GAS_LIMIT.high,
                })
        ).to.be.revertedWith(
            `AccessControl: account ${account_B.toLowerCase()} is missing role ${PAUSE_MANAGER_ROLE}`
        )
    })

    it('GIVEN an account with PAUSE_MANAGER_ROLE WHEN updating external pauses THEN it succeeds', async () => {
        // Ensure starting state
        expect(
            await externalPauseManagement.isExternalPause(
                externalPauseMock1.address
            )
        ).to.be.true
        expect(
            await externalPauseManagement.isExternalPause(
                externalPauseMock2.address
            )
        ).to.be.true

        const pauses = [externalPauseMock1.address, externalPauseMock2.address]
        const actives = [false, true] // Remove mock1, keep mock2
        await expect(
            externalPauseManagement.updateExternalPauses(pauses, actives, {
                gasLimit: GAS_LIMIT.high,
            })
        )
            .to.emit(externalPauseManagement, 'ExternalPausesUpdated')
            .withArgs(account_A, pauses, actives)
        expect(
            await externalPauseManagement.isExternalPause(
                externalPauseMock1.address
            )
        ).to.be.false
        expect(
            await externalPauseManagement.isExternalPause(
                externalPauseMock2.address
            )
        ).to.be.true
    })

    // --- Static Resolver/Interface Functions ---
    // These tests remain valid as they check constants and interface definitions
    it('WHEN getStaticResolverKey is called THEN it returns the correct key', async () => {
        const expectedKey = PAUSE_MANAGEMENT_RESOLVER_KEY
        expect(await externalPauseManagement.getStaticResolverKey()).to.equal(
            expectedKey
        )
    })

    it('WHEN getStaticFunctionSelectors is called THEN it returns the correct selectors', async () => {
        const expectedSelectors = [
            externalPauseManagement.interface.getSighash(
                'initialize_ExternalPauses(address[])'
            ), // Still part of interface
            externalPauseManagement.interface.getSighash(
                'updateExternalPauses(address[],bool[])'
            ),
            externalPauseManagement.interface.getSighash(
                'addExternalPause(address)'
            ),
            externalPauseManagement.interface.getSighash(
                'removeExternalPause(address)'
            ),
            externalPauseManagement.interface.getSighash(
                'isExternalPause(address)'
            ),
            externalPauseManagement.interface.getSighash(
                'getExternalPausesCount()'
            ),
            externalPauseManagement.interface.getSighash(
                'getExternalPausesMembers(uint256,uint256)'
            ),
        ]
        const actualSelectors =
            await externalPauseManagement.getStaticFunctionSelectors()
        expect(actualSelectors).to.have.lengthOf(expectedSelectors.length)
        expect(actualSelectors).to.deep.equal(expectedSelectors) // Order should be deterministic
    })

    it('WHEN getStaticInterfaceIds is called THEN it returns the correct interface ID', async () => {
        const externalPauseMgmtInterface = new ethers.utils.Interface(
            IExternalPauseManagement__factory.abi
        )
        const selectors = [
            // Must include initialize for correct ID
            'initialize_ExternalPauses(address[])',
            'updateExternalPauses(address[],bool[])',
            'addExternalPause(address)',
            'removeExternalPause(address)',
            'isExternalPause(address)',
            'getExternalPausesCount()',
            'getExternalPausesMembers(uint256,uint256)',
        ]
        let calculatedId = BigInt(0)
        for (const selector of selectors) {
            calculatedId =
                calculatedId ^
                BigInt(externalPauseMgmtInterface.getSighash(selector))
        }
        const expectedInterfaceId = ethers.utils.hexZeroPad(
            ethers.utils.hexlify(calculatedId),
            4
        )

        const expectedInterfaceIds = [expectedInterfaceId] // Function returns an array
        const actualInterfaceIds =
            await externalPauseManagement.getStaticInterfaceIds()

        expect(actualInterfaceIds).to.deep.equal(expectedInterfaceIds)
    })
})
