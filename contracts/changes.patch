diff --git a/contracts/contracts/layer_1/hold/Hold.sol b/contracts/contracts/layer_1/hold/Hold.sol
index ab655b9..b0a3534 100644
--- a/contracts/contracts/layer_1/hold/Hold.sol
+++ b/contracts/contracts/layer_1/hold/Hold.sol
@@ -301,7 +301,6 @@ abstract contract Hold is
         onlyValidAddress(_from)
         onlyValidAddress(_hold.escrow)
         onlyDefaultPartitionWithSinglePartition(_partition)
-        onlyWithValidExpirationTimestamp(_hold.expirationTimestamp)
         onlyOperator(_partition, _from)
         onlyUnProtectedPartitionsOrWildCardRole
         returns (bool success_, uint256 holdId_)
@@ -336,7 +335,6 @@ abstract contract Hold is
         onlyValidAddress(_from)
         onlyValidAddress(_hold.escrow)
         onlyDefaultPartitionWithSinglePartition(_partition)
-        onlyWithValidExpirationTimestamp(_hold.expirationTimestamp)
         onlyRole(_CONTROLLER_ROLE)
         onlyControllable
         returns (bool success_, uint256 holdId_)
@@ -370,9 +368,6 @@ abstract contract Hold is
         onlyValidAddress(_from)
         onlyValidAddress(_protectedHold.hold.escrow)
         onlyRole(_protectedPartitionsRole(_partition))
-        onlyWithValidExpirationTimestamp(
-            _protectedHold.hold.expirationTimestamp
-        )
         onlyProtectedPartitions
         returns (bool success_, uint256 holdId_)
     {
@@ -395,7 +390,6 @@ abstract contract Hold is
     function executeHoldByPartition(
         bytes32 _partition,
         uint256 _escrowId,
-        address _tokenHolder,
         address _to,
         uint256 _amount
     )
@@ -404,35 +398,30 @@ abstract contract Hold is
         override
         onlyUnpaused
         onlyDefaultPartitionWithSinglePartition(_partition)
-        onlyWithValidEscrowHoldId(
-            _partition,
-            _msgSender(),
-            _escrowId,
-            _tokenHolder
-        )
-        checkControlList(_tokenHolder)
+        onlyWithValidEscrowHoldId(_partition, _msgSender(), _escrowId)
         checkControlList(_to)
         returns (bool success_)
     {
-        success_ = _executeHoldByPartition(
+        uint256 holdId_;
+        address tokenHolder_;
+        (success_, holdId_, tokenHolder_) = _executeHoldByPartition(
             _partition,
             _escrowId,
-            _tokenHolder,
             _to,
             _amount
         );
-        emit HoldByPartitionReleased(
-            _tokenHolder,
+        emit HoldByPartitionExecuted(
+            tokenHolder_,
             _partition,
-            _escrowId,
-            _amount
+            holdId_,
+            _amount,
+            _to
         );
     }
 
     function releaseHoldByPartition(
         bytes32 _partition,
         uint256 _escrowId,
-        address _tokenHolder,
         uint256 _amount
     )
         external
@@ -440,36 +429,52 @@ abstract contract Hold is
         override
         onlyUnpaused
         onlyDefaultPartitionWithSinglePartition(_partition)
-        onlyWithValidEscrowHoldId(
-            _partition,
-            _msgSender(),
-            _escrowId,
-            _tokenHolder
-        )
+        onlyWithValidEscrowHoldId(_partition, _msgSender(), _escrowId)
         returns (bool success_)
     {
-        // solhint-disable-next-line
-        success_ = _releaseHoldByPartition(
+        uint256 holdId_;
+        address tokenHolder_;
+        (success_, holdId_, tokenHolder_) = _releaseHoldByPartition(
             _partition,
-            _tokenHolder,
             _escrowId,
             _amount
         );
         emit HoldByPartitionReleased(
-            _tokenHolder,
+            tokenHolder_,
             _partition,
-            _escrowId,
+            holdId_,
             _amount
         );
     }
 
     function reclaimHoldByPartition(
         bytes32 _partition,
-        uint256 _holdId,
-        address _tokenHolder
-    ) external returns (bool success_) {
-        // solhint-disable-next-line
-        revert('Should never reach this part');
+        uint256 _escrowId,
+        address _escrowAddress
+    )
+        external
+        virtual
+        override
+        onlyUnpaused
+        onlyDefaultPartitionWithSinglePartition(_partition)
+        onlyWithValidEscrowHoldId(_partition, _escrowAddress, _escrowId)
+        returns (bool success_)
+    {
+        uint256 holdId_;
+        address tokenHolder_;
+        uint256 amount_;
+        (success_, amount_, holdId_, tokenHolder_) = _reclaimHoldByPartition(
+            _partition,
+            _escrowId,
+            _escrowAddress
+        );
+        emit HoldByPartitionReclaimed(
+            _msgSender(),
+            tokenHolder_,
+            _partition,
+            holdId_,
+            amount_
+        );
     }
 
     function getHeldAmountFor(
diff --git a/contracts/contracts/layer_1/hold/HoldStorageWrapper.sol b/contracts/contracts/layer_1/hold/HoldStorageWrapper.sol
index 4e10567..746e84f 100644
--- a/contracts/contracts/layer_1/hold/HoldStorageWrapper.sol
+++ b/contracts/contracts/layer_1/hold/HoldStorageWrapper.sol
@@ -311,31 +311,46 @@ abstract contract HoldStorageWrapper is
     function _executeHoldByPartition(
         bytes32 _partition,
         uint256 _escrowId,
-        address _tokenHolder,
         address _to,
         uint256 _amount
-    ) internal virtual returns (bool success_) {
+    )
+        internal
+        virtual
+        returns (bool success_, uint256 holdId_, address tokenHolder_)
+    {
         IHold.HoldData memory holdData = _getHoldFromEscrowId(
             _partition,
             _msgSender(),
-            _escrowId,
-            _tokenHolder
+            _escrowId
+        );
+        tokenHolder_ = _getTokenHolderFromEscrowId(
+            _partition,
+            _msgSender(),
+            _escrowId
         );
 
         IHold.Hold memory hold = holdData.hold;
 
+        if (_amount > hold.amount) {
+            revert IHold.InsufficientHoldBalance(holdData.hold.amount, _amount);
+        }
+
         if (hold.to != address(0) && _to != hold.to) {
             revert IHold.InvalidDestinationAddress(hold.to, _to);
         }
 
-        _beforeExecuteHold(_partition, _tokenHolder, _to);
+        if (_blockTimestamp() > hold.expirationTimestamp) {
+            revert IHold.HoldExpirationReached();
+        }
 
-        _decreaseHeldAmount(_partition, _tokenHolder, _amount, holdData.id);
+        _beforeExecuteHold(_partition, tokenHolder_, _to);
+
+        _decreaseHeldAmount(_partition, tokenHolder_, _amount, holdData.id);
 
         if (hold.amount == _amount) {
             _removeHold(
                 _partition,
-                _tokenHolder,
+                tokenHolder_,
                 holdData.id,
                 _msgSender(),
                 _escrowId
@@ -349,44 +364,115 @@ abstract contract HoldStorageWrapper is
         }
 
         success_ = true;
+        holdId_ = holdData.id;
     }
 
     function _releaseHoldByPartition(
         bytes32 _partition,
-        address _tokenHolder,
         uint256 _escrowId,
         uint256 _amount
-    ) internal virtual returns (bool success_) {
+    )
+        internal
+        virtual
+        returns (bool success_, uint256 holdId_, address tokenHolder_)
+    {
         IHold.HoldData memory holdData = _getHoldFromEscrowId(
             _partition,
             _msgSender(),
-            _escrowId,
-            _tokenHolder
+            _escrowId
+        );
+        tokenHolder_ = _getTokenHolderFromEscrowId(
+            _partition,
+            _msgSender(),
+            _escrowId
         );
 
         IHold.Hold memory hold = holdData.hold;
 
-        _beforeReleaseHold(_partition, _tokenHolder, _tokenHolder);
+        if (_amount > hold.amount) {
+            revert IHold.InsufficientHoldBalance(holdData.hold.amount, _amount);
+        }
 
-        _decreaseHeldAmount(_partition, _tokenHolder, _amount, holdData.id);
+        if (_blockTimestamp() > hold.expirationTimestamp) {
+            revert IHold.HoldExpirationReached();
+        }
+
+        _beforeReleaseHold(_partition, tokenHolder_, tokenHolder_);
+
+        _decreaseHeldAmount(_partition, tokenHolder_, _amount, holdData.id);
 
         if (hold.amount == _amount) {
             _removeHold(
                 _partition,
-                _tokenHolder,
+                tokenHolder_,
                 holdData.id,
                 _msgSender(),
                 _escrowId
             );
         }
 
-        if (!_validPartitionForReceiver(_partition, _tokenHolder)) {
-            _addPartitionTo(_amount, _tokenHolder, _partition);
+        if (!_validPartitionForReceiver(_partition, tokenHolder_)) {
+            _addPartitionTo(_amount, tokenHolder_, _partition);
+        } else {
+            _increaseBalanceByPartition(tokenHolder_, _amount, _partition);
+        }
+
+        success_ = true;
+        holdId_ = holdData.id;
+    }
+
+    function _reclaimHoldByPartition(
+        bytes32 _partition,
+        uint256 _escrowId,
+        address _escrowAddress
+    )
+        internal
+        virtual
+        returns (
+            bool success_,
+            uint256 amount_,
+            uint256 holdId_,
+            address tokenHolder_
+        )
+    {
+        IHold.HoldData memory holdData = _getHoldFromEscrowId(
+            _partition,
+            _escrowAddress,
+            _escrowId
+        );
+        // Updated hold
+        IHold.Hold memory hold = holdData.hold;
+        tokenHolder_ = _getTokenHolderFromEscrowId(
+            _partition,
+            _msgSender(),
+            _escrowId
+        );
+
+        if (_blockTimestamp() < hold.expirationTimestamp) {
+            revert IHold.HoldExpirationNotReached();
+        }
+
+        _beforeReclaimHold(_partition, tokenHolder_, tokenHolder_);
+
+        _decreaseHeldAmount(_partition, tokenHolder_, hold.amount, holdData.id);
+
+        _removeHold(
+            _partition,
+            tokenHolder_,
+            holdData.id,
+            _escrowAddress,
+            _escrowId
+        );
+
+        if (!_validPartitionForReceiver(_partition, tokenHolder_)) {
+            _addPartitionTo(hold.amount, tokenHolder_, _partition);
         } else {
-            _increaseBalanceByPartition(_tokenHolder, _amount, _partition);
+            _increaseBalanceByPartition(tokenHolder_, hold.amount, _partition);
         }
 
         success_ = true;
+        amount_ = hold.amount;
+        holdId_ = holdData.id;
     }
 
     function _decreaseHeldAmount(
@@ -462,7 +548,7 @@ abstract contract HoldStorageWrapper is
             );
         }
 
-        holdStorage.escrow_holds[_msgSender()][_partition].pop();
+        holdStorage.escrow_holds[_escrow][_partition].pop();
     }
 
     function _setHoldAtIndex(
@@ -504,8 +590,8 @@ abstract contract HoldStorageWrapper is
             .id = escrowHold.id;
 
         holdStorage.escrow_holdsIndex[_escrowAddress][_partition][
-            escrowHold.id
-        ] = _escrowHoldIndex;
+                escrowHold.id
+            ] = _escrowHoldIndex;
     }
 
     function _checkCreateHoldSignature(
diff --git a/contracts/contracts/layer_1/hold/HoldStorageWrapperRead.sol b/contracts/contracts/layer_1/hold/HoldStorageWrapperRead.sol
index ddaa65b..259ccd6 100644
--- a/contracts/contracts/layer_1/hold/HoldStorageWrapperRead.sol
+++ b/contracts/contracts/layer_1/hold/HoldStorageWrapperRead.sol
@@ -220,42 +220,46 @@ abstract contract HoldStorageWrapperRead is LocalContext {
     modifier onlyWithValidEscrowHoldId(
         bytes32 _partition,
         address _escrowAddress,
-        uint256 _escrowId,
-        address _tokenHolder
+        uint256 _escrowId
     ) {
-        if (
-            !_isEscrowHoldIdValid(
-                _partition,
-                _escrowAddress,
-                _escrowId,
-                _tokenHolder
-            )
-        ) revert IHold.WrongEscrowHoldId();
+        if (!_isEscrowHoldIdValid(_partition, _escrowAddress, _escrowId))
+            revert IHold.WrongEscrowHoldId();
         _;
     }
 
     function _isEscrowHoldIdValid(
         bytes32 _partition,
         address _escrowAddress,
-        uint256 _escrowId,
-        address _tokenHolder
+        uint256 _escrowId
     ) internal view returns (bool) {
-        if (
-            _getHoldFromEscrowId(
-                _partition,
-                _escrowAddress,
-                _escrowId,
-                _tokenHolder
-            ).id == 0
-        ) return false;
+        if (_getHoldFromEscrowId(_partition, _escrowAddress, _escrowId).id == 0)
+            return false;
         return true;
     }
 
+    function _getTokenHolderFromEscrowId(
+        bytes32 _partition,
+        address _escrow,
+        uint256 _escrowId
+    ) internal view returns (address tokenHolder_) {
+        uint256 escrowHoldIndex = _getHoldEscrowIndex(
+            _partition,
+            _escrow,
+            _escrowId
+        );
+        IHold.EscrowHoldData memory escrowHold = _getEscrowHoldByIndex(
+            _partition,
+            _escrow,
+            escrowHoldIndex
+        );
+
+        tokenHolder_ = escrowHold.tokenHolder;
+    }
+
     function _getHoldFromEscrowId(
         bytes32 _partition,
         address _escrow,
-        uint256 _escrowId,
-        address _tokenHolder
+        uint256 _escrowId
     ) internal view returns (IHold.HoldData memory holdData_) {
         uint256 escrowHoldIndex = _getHoldEscrowIndex(
             _partition,
@@ -270,11 +274,15 @@ abstract contract HoldStorageWrapperRead is LocalContext {
 
         uint256 holdIndex = _getHoldIndex(
             _partition,
-            _tokenHolder,
+            escrowHold.tokenHolder,
             escrowHold.id
         );
 
-        holdData_ = _getHoldByIndex(_partition, _tokenHolder, holdIndex);
+        holdData_ = _getHoldByIndex(
+            _partition,
+            escrowHold.tokenHolder,
+            holdIndex
+        );
     }
 
     function _getHold(
diff --git a/contracts/contracts/layer_1/interfaces/hold/IHold.sol b/contracts/contracts/layer_1/interfaces/hold/IHold.sol
index d10f56d..b9cc737 100644
--- a/contracts/contracts/layer_1/interfaces/hold/IHold.sol
+++ b/contracts/contracts/layer_1/interfaces/hold/IHold.sol
@@ -221,7 +221,7 @@ interface IHold {
     event HoldByPartitionExecuted(
         address indexed tokenHolder,
         bytes32 indexed partition,
-        uint256 escrowId,
+        uint256 holdId,
         uint256 amount,
         address to
     );
@@ -229,7 +229,7 @@ interface IHold {
     event HoldByPartitionReleased(
         address indexed tokenHolder,
         bytes32 indexed partition,
-        uint256 escrowId,
+        uint256 holdId,
         uint256 amount
     );
 
@@ -237,13 +237,15 @@ interface IHold {
         address indexed operator,
         address indexed tokenHolder,
         bytes32 indexed partition,
-        uint256 escrowId,
+        uint256 holdId,
         uint256 amount
     );
 
     error HoldExpirationNotReached();
     error WrongEscrowHoldId();
     error InvalidDestinationAddress(address holdDestination, address to);
+    error InsufficientHoldBalance(uint256 holdAmount, uint256 amount);
+    error HoldExpirationReached();
 
     struct Hold {
         uint256 amount;
@@ -320,7 +322,6 @@ interface IHold {
     function executeHoldByPartition(
         bytes32 _partition,
         uint256 _escrowId,
-        address _tokenHolder,
         address _to,
         uint256 _amount
     ) external returns (bool success_);
@@ -328,14 +329,13 @@ interface IHold {
     function releaseHoldByPartition(
         bytes32 _partition,
         uint256 _escrowId,
-        address _tokenHolder,
         uint256 _amount
     ) external returns (bool success_);
 
     function reclaimHoldByPartition(
         bytes32 _partition,
         uint256 _escrowId,
-        address _tokenHolder
+        address _escrowAddress
     ) external returns (bool success_);
 
     function getHeldAmountFor(
diff --git a/contracts/contracts/layer_2/hold/HoldStorageWrapper_2.sol b/contracts/contracts/layer_2/hold/HoldStorageWrapper_2.sol
index 253368f..9fc8e83 100644
--- a/contracts/contracts/layer_2/hold/HoldStorageWrapper_2.sol
+++ b/contracts/contracts/layer_2/hold/HoldStorageWrapper_2.sol
@@ -331,6 +331,7 @@ abstract contract HoldStorageWrapper_2 is
 
         amount_ *= factor;
     }
+
     function _createHoldByPartition(
         bytes32 _partition,
         address _from,
@@ -366,15 +367,25 @@ abstract contract HoldStorageWrapper_2 is
     function _executeHoldByPartition(
         bytes32 _partition,
         uint256 _escrowId,
-        address _tokenHolder,
         address _to,
         uint256 _amount
-    ) internal virtual override returns (bool success_) {
+    )
+        internal
+        virtual
+        override
+        returns (bool success_, uint256 holdId_, address tokenHolder_)
+    {
+        tokenHolder_ = _getTokenHolderFromEscrowId(
+            _partition,
+            _msgSender(),
+            _escrowId
+        );
+        _checkControlList(tokenHolder_);
+
         IHold.HoldData memory holdData = _getHoldFromEscrowId(
             _partition,
             _msgSender(),
-            _escrowId,
-            _tokenHolder
+            _escrowId
         );
 
         AdjustBalancesStorage
@@ -383,71 +394,153 @@ abstract contract HoldStorageWrapper_2 is
         ERC1410ScheduledTasks_CD_Lib.triggerAndSyncAll(
             _partition,
             address(0),
-            _tokenHolder
+            tokenHolder_
         );
 
         uint256 abaf = _updateTotalHold(
             _partition,
-            _tokenHolder,
+            tokenHolder_,
             adjustBalancesStorage
         );
 
-        _updateHoldByIndex(_partition, holdData.id, _tokenHolder, abaf);
+        _updateHoldByIndex(
+            _partition,
+            holdData.id,
+            tokenHolder_,
+            abaf,
+            adjustBalancesStorage
+        );
 
-        success_ = super._executeHoldByPartition(
+        (success_, holdId_, ) = super._executeHoldByPartition(
             _partition,
             _escrowId,
-            _tokenHolder,
             _to,
             _amount
         );
-
+        // Updated hold amount
+        holdData = _getHoldFromEscrowId(_partition, _msgSender(), _escrowId);
         if (_amount == holdData.hold.amount) {
-            adjustBalancesStorage.labafHolds[_tokenHolder][_partition].pop();
+            adjustBalancesStorage.labafHolds[tokenHolder_][_partition].pop();
         }
     }
 
     function _releaseHoldByPartition(
         bytes32 _partition,
-        address _tokenHolder,
         uint256 _escrowId,
         uint256 _amount
-    ) internal virtual override returns (bool success_) {
+    )
+        internal
+        virtual
+        override
+        returns (bool success_, uint256 holdId_, address tokenHolder_)
+    {
+        tokenHolder_ = _getTokenHolderFromEscrowId(
+            _partition,
+            _msgSender(),
+            _escrowId
+        );
+
+        _checkControlList(tokenHolder_);
+
         IHold.HoldData memory holdData = _getHoldFromEscrowId(
             _partition,
             _msgSender(),
-            _escrowId,
-            _tokenHolder
+            _escrowId
         );
+
         AdjustBalancesStorage
             storage adjustBalancesStorage = _getAdjustBalancesStorage();
 
         ERC1410ScheduledTasks_CD_Lib.triggerAndSyncAll(
             _partition,
             address(0),
-            _tokenHolder
+            tokenHolder_
         );
 
         uint256 abaf = _updateTotalHold(
             _partition,
-            _tokenHolder,
+            tokenHolder_,
             adjustBalancesStorage
         );
 
-        _updateHoldByIndex(_partition, holdData.id, _tokenHolder, abaf);
+        _updateHoldByIndex(
+            _partition,
+            holdData.id,
+            tokenHolder_,
+            abaf,
+            adjustBalancesStorage
+        );
 
-        success_ = super._releaseHoldByPartition(
+        (success_, holdId_, ) = super._releaseHoldByPartition(
             _partition,
-            _tokenHolder,
             _escrowId,
             _amount
         );
 
+        // Updated hold amount
+        holdData = _getHoldFromEscrowId(_partition, _msgSender(), _escrowId);
         if (_amount == holdData.hold.amount) {
-            adjustBalancesStorage.labafHolds[_tokenHolder][_partition].pop();
+            adjustBalancesStorage.labafHolds[tokenHolder_][_partition].pop();
         }
     }
 
+    function _reclaimHoldByPartition(
+        bytes32 _partition,
+        uint256 _escrowId,
+        address _escrowAddress
+    )
+        internal
+        virtual
+        override
+        returns (
+            bool success_,
+            uint256 amount_,
+            uint256 holdId_,
+            address tokenHolder_
+        )
+    {
+        tokenHolder_ = _getTokenHolderFromEscrowId(
+            _partition,
+            _escrowAddress,
+            _escrowId
+        );
+        _checkControlList(tokenHolder_);
+
+        IHold.HoldData memory holdData = _getHoldFromEscrowId(
+            _partition,
+            _escrowAddress,
+            _escrowId
+        );
+
+        AdjustBalancesStorage
+            storage adjustBalancesStorage = _getAdjustBalancesStorage();
+
+        ERC1410ScheduledTasks_CD_Lib.triggerAndSyncAll(
+            _partition,
+            address(0),
+            tokenHolder_
+        );
+
+        uint256 abaf = _updateTotalHold(
+            _partition,
+            tokenHolder_,
+            adjustBalancesStorage
+        );
+
+        _updateHoldByIndex(
+            _partition,
+            holdData.id,
+            tokenHolder_,
+            abaf,
+            adjustBalancesStorage
+        );
+
+        (success_, amount_, holdId_, tokenHolder_) = super
+            ._reclaimHoldByPartition(_partition, _escrowId, _escrowAddress);
+
+        adjustBalancesStorage.labafHolds[tokenHolder_][_partition].pop();
+    }
+
     function _setHoldAtIndex(
         bytes32 _partition,
         address _tokenHolder,
@@ -456,14 +549,14 @@ abstract contract HoldStorageWrapper_2 is
     ) internal virtual override {
         AdjustBalancesStorage
             storage adjustBalancesStorage = _getAdjustBalancesStorage();
-        uint256 holdIndex = _getHoldIndex(
+        uint256 currentHoldIndex = _getHoldIndex(
             _partition,
             _tokenHolder,
             _holdData.id
         );
         uint256 labaf = adjustBalancesStorage.labafHolds[_tokenHolder][
             _partition
-        ][holdIndex - 1];
+        ][currentHoldIndex - 1];
 
         adjustBalancesStorage.labafHolds[_tokenHolder][_partition][
             _holdIndex - 1
@@ -473,7 +566,7 @@ abstract contract HoldStorageWrapper_2 is
             super._setHoldAtIndex(
                 _partition,
                 _tokenHolder,
-                holdIndex,
+                _holdIndex,
                 _holdData
             );
     }
@@ -549,9 +642,10 @@ abstract contract HoldStorageWrapper_2 is
         bytes32 _partition,
         uint256 _holdId,
         address _tokenHolder,
-        uint256 _abaf
+        uint256 _abaf,
+        AdjustBalancesStorage storage adjustBalancesStorage
     ) internal virtual {
-        uint256 hold_LABAF = AdjustBalances_CD_Lib.getLockLABAFByPartition(
+        uint256 hold_LABAF = AdjustBalances_CD_Lib.getHoldLABAFByPartition(
             _partition,
             _holdId,
             _tokenHolder
@@ -575,6 +669,9 @@ abstract contract HoldStorageWrapper_2 is
                 _tokenHolder,
                 factor_hold
             );
+            adjustBalancesStorage.labafHolds[_tokenHolder][_partition][
+                holdIndex - 1
+            ] = _abaf;
         }
     }
 
diff --git a/contracts/contracts/layer_2/hold/Hold_2.sol b/contracts/contracts/layer_2/hold/Hold_2.sol
index d7036ce..0847c94 100644
--- a/contracts/contracts/layer_2/hold/Hold_2.sol
+++ b/contracts/contracts/layer_2/hold/Hold_2.sol
@@ -351,43 +351,49 @@ contract Hold_2 is
     function _executeHoldByPartition(
         bytes32 _partition,
         uint256 _escrowId,
-        address _tokenHolder,
         address _to,
         uint256 _amount
     )
         internal
         virtual
         override(HoldStorageWrapper, HoldStorageWrapper_2)
-        returns (bool success_)
+        returns (bool success_, uint256 holdId_, address tokenHolder_)
     {
-        return
-            HoldStorageWrapper_2._executeHoldByPartition(
-                _partition,
-                _escrowId,
-                _tokenHolder,
-                _to,
-                _amount
-            );
+        (success_, holdId_, tokenHolder_) = HoldStorageWrapper_2
+            ._executeHoldByPartition(_partition, _escrowId, _to, _amount);
     }
 
     function _releaseHoldByPartition(
         bytes32 _partition,
-        address _tokenHolder,
         uint256 _escrowId,
         uint256 _amount
     )
         internal
         virtual
         override(HoldStorageWrapper, HoldStorageWrapper_2)
-        returns (bool success_)
+        returns (bool success_, uint256 holdId_, address tokenHolder_)
     {
-        return
-            HoldStorageWrapper_2._releaseHoldByPartition(
-                _partition,
-                _tokenHolder,
-                _escrowId,
-                _amount
-            );
+        (success_, holdId_, tokenHolder_) = HoldStorageWrapper_2
+            ._releaseHoldByPartition(_partition, _escrowId, _amount);
+    }
+
+    function _reclaimHoldByPartition(
+        bytes32 _partition,
+        uint256 _escrowId,
+        address _escrowAddress
+    )
+        internal
+        virtual
+        override(HoldStorageWrapper, HoldStorageWrapper_2)
+        returns (
+            bool success_,
+            uint256 amount_,
+            uint256 holdId_,
+            address tokenHolder_
+        )
+    {
+        (success_, amount_, holdId_, tokenHolder_) = HoldStorageWrapper_2
+            ._reclaimHoldByPartition(_partition, _escrowId, _escrowAddress);
     }
 
     function getStaticResolverKey()
