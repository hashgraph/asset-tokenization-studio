/*
                                 Apache License
                           Version 2.0, January 2004
                        http://www.apache.org/licenses/

   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION

   1. Definitions.

      "License" shall mean the terms and conditions for use, reproduction,
      and distribution as defined by Sections 1 through 9 of this document.

      "Licensor" shall mean the copyright owner or entity authorized by
      the copyright owner that is granting the License.

      "Legal Entity" shall mean the union of the acting entity and all
      other entities that control, are controlled by, or are under common
      control with that entity. For the purposes of this definition,
      "control" means (i) the power, direct or indirect, to cause the
      direction or management of such entity, whether by contract or
      otherwise, or (ii) ownership of fifty percent (50%) or more of the
      outstanding shares, or (iii) beneficial ownership of such entity.

      "You" (or "Your") shall mean an individual or Legal Entity
      exercising permissions granted by this License.

      "Source" form shall mean the preferred form for making modifications,
      including but not limited to software source code, documentation
      source, and configuration files.

      "Object" form shall mean any form resulting from mechanical
      transformation or translation of a Source form, including but
      not limited to compiled object code, generated documentation,
      and conversions to other media types.

      "Work" shall mean the work of authorship, whether in Source or
      Object form, made available under the License, as indicated by a
      copyright notice that is included in or attached to the work
      (an example is provided in the Appendix below).

      "Derivative Works" shall mean any work, whether in Source or Object
      form, that is based on (or derived from) the Work and for which the
      editorial revisions, annotations, elaborations, or other modifications
      represent, as a whole, an original work of authorship. For the purposes
      of this License, Derivative Works shall not include works that remain
      separable from, or merely link (or bind by name) to the interfaces of,
      the Work and Derivative Works thereof.

      "Contribution" shall mean any work of authorship, including
      the original version of the Work and any modifications or additions
      to that Work or Derivative Works thereof, that is intentionally
      submitted to Licensor for inclusion in the Work by the copyright owner
      or by an individual or Legal Entity authorized to submit on behalf of
      the copyright owner. For the purposes of this definition, "submitted"
      means any form of electronic, verbal, or written communication sent
      to the Licensor or its representatives, including but not limited to
      communication on electronic mailing lists, source code control systems,
      and issue tracking systems that are managed by, or on behalf of, the
      Licensor for the purpose of discussing and improving the Work, but
      excluding communication that is conspicuously marked or otherwise
      designated in writing by the copyright owner as "Not a Contribution."

      "Contributor" shall mean Licensor and any individual or Legal Entity
      on behalf of whom a Contribution has been received by Licensor and
      subsequently incorporated within the Work.

   2. Grant of Copyright License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      copyright license to reproduce, prepare Derivative Works of,
      publicly display, publicly perform, sublicense, and distribute the
      Work and such Derivative Works in Source or Object form.

   3. Grant of Patent License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      (except as stated in this section) patent license to make, have made,
      use, offer to sell, sell, import, and otherwise transfer the Work,
      where such license applies only to those patent claims licensable
      by such Contributor that are necessarily infringed by their
      Contribution(s) alone or by combination of their Contribution(s)
      with the Work to which such Contribution(s) was submitted. If You
      institute patent litigation against any entity (including a
      cross-claim or counterclaim in a lawsuit) alleging that the Work
      or a Contribution incorporated within the Work constitutes direct
      or contributory patent infringement, then any patent licenses
      granted to You under this License for that Work shall terminate
      as of the date such litigation is filed.

   4. Redistribution. You may reproduce and distribute copies of the
      Work or Derivative Works thereof in any medium, with or without
      modifications, and in Source or Object form, provided that You
      meet the following conditions:

      (a) You must give any other recipients of the Work or
          Derivative Works a copy of this License; and

      (b) You must cause any modified files to carry prominent notices
          stating that You changed the files; and

      (c) You must retain, in the Source form of any Derivative Works
          that You distribute, all copyright, patent, trademark, and
          attribution notices from the Source form of the Work,
          excluding those notices that do not pertain to any part of
          the Derivative Works; and

      (d) If the Work includes a "NOTICE" text file as part of its
          distribution, then any Derivative Works that You distribute must
          include a readable copy of the attribution notices contained
          within such NOTICE file, excluding those notices that do not
          pertain to any part of the Derivative Works, in at least one
          of the following places: within a NOTICE text file distributed
          as part of the Derivative Works; within the Source form or
          documentation, if provided along with the Derivative Works; or,
          within a display generated by the Derivative Works, if and
          wherever such third-party notices normally appear. The contents
          of the NOTICE file are for informational purposes only and
          do not modify the License. You may add Your own attribution
          notices within Derivative Works that You distribute, alongside
          or as an addendum to the NOTICE text from the Work, provided
          that such additional attribution notices cannot be construed
          as modifying the License.

      You may add Your own copyright statement to Your modifications and
      may provide additional or different license terms and conditions
      for use, reproduction, or distribution of Your modifications, or
      for any such Derivative Works as a whole, provided Your use,
      reproduction, and distribution of the Work otherwise complies with
      the conditions stated in this License.

   5. Submission of Contributions. Unless You explicitly state otherwise,
      any Contribution intentionally submitted for inclusion in the Work
      by You to the Licensor shall be under the terms and conditions of
      this License, without any additional terms or conditions.
      Notwithstanding the above, nothing herein shall supersede or modify
      the terms of any separate license agreement you may have executed
      with Licensor regarding such Contributions.

   6. Trademarks. This License does not grant permission to use the trade
      names, trademarks, service marks, or product names of the Licensor,
      except as required for reasonable and customary use in describing the
      origin of the Work and reproducing the content of the NOTICE file.

   7. Disclaimer of Warranty. Unless required by applicable law or
      agreed to in writing, Licensor provides the Work (and each
      Contributor provides its Contributions) on an "AS IS" BASIS,
      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
      implied, including, without limitation, any warranties or conditions
      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
      PARTICULAR PURPOSE. You are solely responsible for determining the
      appropriateness of using or redistributing the Work and assume any
      risks associated with Your exercise of permissions under this License.

   8. Limitation of Liability. In no event and under no legal theory,
      whether in tort (including negligence), contract, or otherwise,
      unless required by applicable law (such as deliberate and grossly
      negligent acts) or agreed to in writing, shall any Contributor be
      liable to You for damages, including any direct, indirect, special,
      incidental, or consequential damages of any character arising as a
      result of this License or out of the use or inability to use the
      Work (including but not limited to damages for loss of goodwill,
      work stoppage, computer failure or malfunction, or any and all
      other commercial damages or losses), even if such Contributor
      has been advised of the possibility of such damages.

   9. Accepting Warranty or Additional Liability. While redistributing
      the Work or Derivative Works thereof, You may choose to offer,
      and charge a fee for, acceptance of support, warranty, indemnity,
      or other liability obligations and/or rights consistent with this
      License. However, in accepting such obligations, You may act only
      on Your own behalf and on Your sole responsibility, not on behalf
      of any other Contributor, and only if You agree to indemnify,
      defend, and hold each Contributor harmless for any liability
      incurred by, or claims asserted against, such Contributor by reason
      of your accepting any such warranty or additional liability.

   END OF TERMS AND CONDITIONS

   APPENDIX: How to apply the Apache License to your work.

      To apply the Apache License to your work, attach the following
      boilerplate notice, with the fields enclosed by brackets "[]"
      replaced with your own identifying information. (Don't include
      the brackets!)  The text should be enclosed in the appropriate
      comment syntax for the file format. We also recommend that a
      file or class name and description of purpose be included on the
      same "printed page" as the copyright notice for easier
      identification within third-party archives.

   Copyright [yyyy] [name of copyright owner]

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.

*/
// SPDX-License-Identifier: UNLICENSED
pragma solidity 0.8.18;

// solhint-disable max-line-length

import { ILifeCycleCashFlow } from "./interfaces/ILifeCycleCashFlow.sol";
import {
    HederaTokenService
} from "@hashgraph/smart-contracts/contracts/system-contracts/hedera-token-service/HederaTokenService.sol";
import { Pause } from "./core/Pause.sol";
import { AccessControl } from "./core/AccessControl.sol";
import { IERC20 } from "@hashgraph/asset-tokenization-contracts/contracts/layer_1/interfaces/ERC1400/IERC20.sol";
import { IERC20 as OZ_IERC20 } from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import { ERC20 } from "@hashgraph/asset-tokenization-contracts/contracts/layer_1/ERC1400/ERC20/ERC20.sol";
import { IERC1410 } from "@hashgraph/asset-tokenization-contracts/contracts/layer_1/interfaces/ERC1400/IERC1410.sol";
import {
    ISnapshots
} from "@hashgraph/asset-tokenization-contracts/contracts/layer_1/interfaces/snapshots/ISnapshots.sol";
import { IBond } from "@hashgraph/asset-tokenization-contracts/contracts/layer_2/interfaces/bond/IBond.sol";
import { IBondRead } from "@hashgraph/asset-tokenization-contracts/contracts/layer_2/interfaces/bond/IBondRead.sol";
import { IEquity } from "@hashgraph/asset-tokenization-contracts/contracts/layer_2/interfaces/equity/IEquity.sol";
import { ISecurity } from "@hashgraph/asset-tokenization-contracts/contracts/layer_3/interfaces/ISecurity.sol";
import { _DEFAULT_PARTITION, _PERCENTAGE_DECIMALS_SIZE } from "./constants/values.sol";
import { _LIFECYCLE_CASH_FLOW_STORAGE_POSITION } from "./constants/storagePositions.sol";

abstract contract LifeCycleCashFlowStorageWrapper is ILifeCycleCashFlow, HederaTokenService, Pause, AccessControl {
    struct LifeCycleCashFlowStorage {
        address asset;
        ILifeCycleCashFlow.AssetType assetType;
        OZ_IERC20 paymentToken;
        mapping(uint256 => mapping(address => bool)) paidAddressesByDistribution;
        mapping(uint256 => mapping(address => bool)) paidAddressesBySnapshot;
    }

    modifier isAsset(address _asset) {
        _checkAsset(_asset);
        _;
    }

    modifier onlyOnDistributionDate(address _asset, uint256 _distributionID) {
        _checkDistributionDate(_asset, _distributionID);
        _;
    }

    modifier onlyOnMaturityDate(address _bond) {
        _checkMaturityDate(_bond);
        _;
    }

    modifier onlyValidPaymentToken(address _paymentToken) {
        _checkPaymentToken(_paymentToken);
        _;
    }
    /*
     * @dev Pay a coupon or dividend to a list of holders
     *
     * @param assetType The type of the asset, bond/equity, the distribution belongs to
     * @param asset The asset the distribution belongs to
     * @param distributionID The coupon/dividend identifier
     * @param pageIndex The index of the page whose holders will be paid
     * @param pageLength The number of holders who will be paid
     *
     * @return The array of the holders addresses whose payment were not successful
     */
    function _executeDistribution(
        ILifeCycleCashFlow.AssetType _assetType,
        address _asset,
        uint256 _distributionID,
        uint256 _pageIndex,
        uint256 _pageLength
    ) internal returns (address[] memory failed_, address[] memory succeeded_, uint256[] memory paidAmount_, bool) {
        address[] memory holders = _getHolders(_assetType, _asset, _distributionID, _pageIndex, _pageLength);
        if (holders.length == 0) return (failed_, succeeded_, paidAmount_, false);
        (failed_, succeeded_, paidAmount_) = _executeDistributionByAddresses(
            _assetType,
            _asset,
            _distributionID,
            holders
        );
        return (failed_, succeeded_, paidAmount_, true);
    }

    /*
     * @dev Retry the payment of a coupon or dividend to a list of holders
     *
     * @param assetType The type of the asset, bond/equity, the distribution belongs to
     * @param asset The asset the distribution belongs to
     * @param distributionID The coupon/dividend identifier
     * @param holders The array of holders addresses who will be paid
     *
     * @return The array of the holders addresses whose payment were not successful
     */
    function _executeDistributionByAddresses(
        ILifeCycleCashFlow.AssetType _assetType,
        address _asset,
        uint256 _distributionID,
        address[] memory _holders
    ) internal returns (address[] memory failed_, address[] memory succeeded_, uint256[] memory paidAmount_) {
        address[] memory filteredHolders = _filterZeroAddresses(_holders);
        (failed_, succeeded_, paidAmount_) = _payHoldersDistribution(
            _assetType,
            _asset,
            _distributionID,
            filteredHolders
        );
    }
    /*
     * @dev Perform a bond cash out to a page of holders
     *
     * @param bond The bond the cash out belongs to
     * @param pageIndex The index of the page whose cash outs will be performed
     * @param pageLength The number of holders who owns the bond to be cashed out
     *
     * @return The array of the holders addresses whose cashes outs were not successful
     * @return True if ATS returns holders for their bonds to be cashed out, and false otherwise
     */
    function _executeBondCashOut(
        address _bond,
        uint256 _pageIndex,
        uint256 _pageLength
    ) internal returns (address[] memory failed_, address[] memory succeeded_, uint256[] memory paidAmount_, bool) {
        address[] memory holders = ISecurity(_bond).getSecurityHolders(_pageIndex, _pageLength);

        if (holders.length == 0) return (failed_, succeeded_, paidAmount_, false);
        (failed_, succeeded_, paidAmount_) = _executeBondCashOutByAddresses(_bond, holders);
        return (failed_, succeeded_, paidAmount_, true);
    }

    /*
     * @dev Perform a bond cash out to a list of holders
     *
     * @param bond The bond the cash out belongs to
     * @param holders The array of holders addresses who will be paid
     *
     * @return The array of the holders addresses whose cash outs were not successful
     */
    function _executeBondCashOutByAddresses(
        address _bond,
        address[] memory _holders
    ) internal returns (address[] memory failed_, address[] memory succeeded_, uint256[] memory paidAmount_) {
        address[] memory filteredHolders = _filterZeroAddresses(_holders);
        (failed_, succeeded_, paidAmount_) = _payHoldersCashOut(_bond, filteredHolders);
    }

    /*
     * @dev Pay a fixed amount of USDC tokens to a page of holders
     *
     * @param asset The asset the snapshot belongs to
     * @param snapshotID The snapshot identifier
     * @param pageIndex The index of the page whose holders will be paid
     * @param pageLength The number of holders who will be paid
     * @param amount The fixed amount to be paid distributed proportionally among the holders
     *
     * @return The array of the holders addresses whose payment were not successful
     * @return True if ATS returns holders to be paid, and false otherwise
     */
    function _executeAmountSnapshot(
        address _asset,
        uint256 _snapshotID,
        uint256 _pageIndex,
        uint256 _pageLength,
        uint256 _amount
    )
        internal
        returns (address[] memory failed_, address[] memory succeeded_, uint256[] memory paidAmount_, bool executed_)
    {
        address[] memory holders = _getHoldersBySnapshot(_asset, _snapshotID, _pageIndex, _pageLength);
        if (holders.length == 0) return (failed_, succeeded_, paidAmount_, false);
        (failed_, succeeded_, paidAmount_) = _executeSnapshotByAddresses(
            _asset,
            _snapshotID,
            holders,
            _amount,
            _getSnapshotAmountByAmount
        );
        return (failed_, succeeded_, paidAmount_, true);
    }

    /*
     * @dev Pay a fixed amount of USDC tokens to a list of holders
     *
     * @param asset The asset the snapshot belongs to
     * @param snapshotID The snapshot identifier
     * @param pageIndex The index of the page whose holders will be paid
     * @param pageLength The number of holders who will be paid
     * @param percentage The contract balance percentage to be paid distributed proportionally among the holders
     *
     * @return The array of the holders addresses whose payment were not successful
     * @return True if ATS returns holders to be paid, and false otherwise
     */
    function _executePercentageSnapshot(
        address _asset,
        uint256 _snapshotID,
        uint256 _pageIndex,
        uint256 _pageLength,
        uint256 _percentage
    )
        internal
        returns (address[] memory failed_, address[] memory succeeded_, uint256[] memory paidAmount_, bool executed_)
    {
        if (_percentage > 100 * 10 ** _PERCENTAGE_DECIMALS_SIZE)
            revert ILifeCycleCashFlow.InvalidPercentage(_percentage);
        address[] memory holders = _getHoldersBySnapshot(_asset, _snapshotID, _pageIndex, _pageLength);
        if (holders.length == 0) return (failed_, succeeded_, paidAmount_, false);
        (failed_, succeeded_, paidAmount_) = _executeSnapshotByAddresses(
            _asset,
            _snapshotID,
            holders,
            _percentage,
            _getSnapshotAmountByPercentage
        );
        return (failed_, succeeded_, paidAmount_, true);
    }

    /*
     * @dev Pay an amount of USDC tokens, or a percentage of contract token balance, to a page of holders
     *
     * @param asset The asset the snapshot belongs to
     * @param snapshotID The snapshot identifier
     * @param holders The array of holders addresses who will be paid * @param snapshotID The snapshot identifier
     * @param amount The fixed amount to be paid distributed proportionally among the holders
     * @param getSnapshotAmount The function to calculate the amount of payment tokens to pay
     *
     * @return The array of the holders addresses whose payment were not successful
     */
    function _executeSnapshotByAddresses(
        address _asset,
        uint256 _snapshotID,
        address[] memory _holders,
        uint256 _amount,
        function(ILifeCycleCashFlow.SnapshotAmountInfo memory) internal returns (uint256) _getSnapshotAmount
    ) internal returns (address[] memory failed_, address[] memory succeeded_, uint256[] memory paidAmount_) {
        address[] memory filteredHolders = _filterZeroAddresses(_holders);
        (failed_, succeeded_, paidAmount_) = _paySnapshotHolders(
            _asset,
            filteredHolders,
            _snapshotID,
            _amount,
            _getSnapshotAmount
        );
    }

    /*
     * @dev Transfers an amount of ERC20 tokens to an address
     *
     * @param to The destination of the amount of USDC tokens
     * @param amount The amount of USDC tokens to be transferred
     */
    function _transferPaymentToken(address _to, uint256 _amount) internal {
        OZ_IERC20 paymentToken = _lifeCycleCashFlowStorage().paymentToken;
        if (paymentToken.balanceOf(address(this)) < _amount) {
            revert ILifeCycleCashFlow.NotEnoughBalance(_amount);
        }

        if (!paymentToken.transfer(_to, _amount)) {
            revert ILifeCycleCashFlow.TransferERC20TokenFailed(_to, _amount);
        }
    }

    /*
     * @dev Set a new payment token
     *
     * @param newPaymentToken The new payment token
     */
    function _updatePaymentToken(address _newPaymentToken) internal {
        _setPaymentToken(OZ_IERC20(_newPaymentToken));
        _associateToken(_newPaymentToken);
    }

    /*
     * @dev Set the asset
     *
     * @param asset The asset to be set
     */
    function _setAsset(address _asset) internal {
        _lifeCycleCashFlowStorage().asset = _asset;
    }

    /*
     * @dev Set the asset type
     *
     * @param assetType The asset type to be set
     */
    function _setAssetType(ILifeCycleCashFlow.AssetType _assetType) internal {
        _lifeCycleCashFlowStorage().assetType = _assetType;
    }

    /*
     * @dev Set the payment token
     *
     * @param token The payment token to be set
     */
    function _setPaymentToken(OZ_IERC20 token) internal {
        _lifeCycleCashFlowStorage().paymentToken = token;
    }

    /*
     * @dev Assign RBAC roles to members
     *
     * @param rbac The array of RBAC roles and members
     */
    function _assignRbacRoles(ILifeCycleCashFlow.Rbac[] memory _rbac) internal {
        for (uint256 rbacIndex; rbacIndex < _rbac.length; rbacIndex++) {
            for (uint256 memberIndex; memberIndex < _rbac[rbacIndex].members.length; memberIndex++) {
                _grantRole(_rbac[rbacIndex].role, _rbac[rbacIndex].members[memberIndex]);
            }
        }
    }

    /*
     * @dev Associate with payment token to the contract
     *
     * @param token The address of the token we want to associate with the contract
     */
    function _associateToken(address _token) internal virtual {
        if (HederaTokenService.associateToken(address(this), _token) != 22) {
            revert ILifeCycleCashFlow.AssociateTokenFailed();
        }

        emit TokenAssociated(_token);
    }

    /*
     * @dev Get snapshot amount to pay for a certain holder
     *
     * @param asset The asset the snapshot belongs to
     * @param snapshotID The snapshot identifier
     * @param holder The holder address to be paidÂ´
     * @param amount The fixed amount to be paid distributed proportionally among the holders
     *
     * @return The amount to be paid
     */
    function _getSnapshotAmountByAmount(
        ILifeCycleCashFlow.SnapshotAmountInfo memory amountInfo
    ) internal view returns (uint256) {
        uint256 holderTokens = ISnapshots(amountInfo.asset).balanceOfAtSnapshot(
            amountInfo.snapshotID,
            amountInfo.holder
        );
        return ((amountInfo.amountOrPercentage * holderTokens) / amountInfo.totalSupplyAtSnapshot);
    }

    /*
     * @dev Get the snapshot amount to pay for a certain holder
     *
     * @param asset The asset the snapshot belongs to
     * @param snapshotID The coupon/dividend identifier
     * @param holder The holder address to be paid
     * @param percentage The contract balance percentage to be paid distributed proportionally among the holders
     *
     * @return The amount to be paid
     */
    function _getSnapshotAmountByPercentage(
        ILifeCycleCashFlow.SnapshotAmountInfo memory amountInfo
    ) internal view returns (uint256) {
        uint256 holderTokens = ISnapshots(amountInfo.asset).balanceOfAtSnapshot(
            amountInfo.snapshotID,
            amountInfo.holder
        );
        return ((amountInfo.paymentTokenBalance * amountInfo.amountOrPercentage * holderTokens) /
            ((100 * 10 ** _PERCENTAGE_DECIMALS_SIZE) * amountInfo.totalSupplyAtSnapshot));
    }

    /*
     * @dev Get the payment token
     *
     * @return The payment token
     */
    function _getPaymentToken() internal view returns (OZ_IERC20) {
        return _lifeCycleCashFlowStorage().paymentToken;
    }

    /*
     * @dev Get the payment token decimals
     *
     * @return The payment token decimals
     */
    function _getPaymentTokenDecimals() internal view returns (uint8) {
        return IERC20(address(_getPaymentToken())).decimals();
    }

    /*
     * @dev Checks if a distribution was already paid to a holder
     *
     * @param distributionID The coupon/dividend identifier
     * @param holder The holder to the if the distribution was already paid
     *
     * @return True if the distribution was already paid to the holder, false otherwise
     */
    function _isDistributionHolderPaid(uint256 _distributionID, address _holder) internal view returns (bool) {
        return _lifeCycleCashFlowStorage().paidAddressesByDistribution[_distributionID][_holder];
    }

    /*
     * @dev Checks if a snapshot was already paid to a holder
     *
     * @param snapshotID The snapshot identifier
     * @param holder The holder to the if the snapshot was already paid
     *
     * @return True if the snapshot was already paid to the holder, false otherwise
     */
    function _isSnapshotHolderPaid(uint256 _snapshotID, address _holder) internal view returns (bool) {
        return _lifeCycleCashFlowStorage().paidAddressesBySnapshot[_snapshotID][_holder];
    }

    /*
     * @dev Get the LifeCycleCashFlow storage
     *
     * @returns The LifeCycleCashFlow storage
     */
    function _lifeCycleCashFlowStorage()
        internal
        pure
        returns (LifeCycleCashFlowStorage storage lifeCycleCashFlowStorage_)
    {
        bytes32 position = _LIFECYCLE_CASH_FLOW_STORAGE_POSITION;
        // solhint-disable-next-line no-inline-assembly
        assembly {
            lifeCycleCashFlowStorage_.slot := position
        }
    }

    /*
     * @dev Change the payment token
     *
     * @param paymentToken The new payment token
     */
    function _setNewPaymentToken(address _paymentToken) private {
        _setPaymentToken(OZ_IERC20(_paymentToken));
        _associateToken(_paymentToken);
    }

    /*
     * @dev Sets a payment to a holder for a distribution
     *
     * @param distributionID The distribution paid to a holder
     * @param holder The holder who was paid
     */
    function _setDistributionHolderPaid(uint256 distributionID, address holder) private {
        _lifeCycleCashFlowStorage().paidAddressesByDistribution[distributionID][holder] = true;
    }

    /*
     * @dev Sets a payment to a holder for a snapshot
     *
     * @param snapshotID The snapshot paid to a holder
     * @param holder The holder who was paid
     */
    function _setSnapshotHolderPaid(uint256 snapshotID, address holder) private {
        _lifeCycleCashFlowStorage().paidAddressesBySnapshot[snapshotID][holder] = true;
    }

    /*
     * @dev Returns the array containing holders addresses who couldn't be paid for a distribution id
     *
     * @param assetType The type of the asset, bond/equity, the distribution belongs to
     * @param asset The asset the distribution belongs to
     * @param distributionID The coupon/dividend identifier
     * @param holders The holders to be paid
     *
     * @return The array of the holders addresses whose payment were not successful for the distribution
     */
    function _payHoldersDistribution(
        ILifeCycleCashFlow.AssetType _assetType,
        address _asset,
        uint256 _distributionID,
        address[] memory _holders
    )
        private
        returns (address[] memory failedAddresses_, address[] memory succeededAddresses_, uint256[] memory paidAmount_)
    {
        failedAddresses_ = new address[](_holders.length);
        succeededAddresses_ = new address[](_holders.length);
        paidAmount_ = new uint256[](_holders.length);
        OZ_IERC20 paymentToken = _lifeCycleCashFlowStorage().paymentToken;

        uint256 failedIndex;
        uint256 succeededIndex;
        uint256 nominalValue;

        if (_assetType == ILifeCycleCashFlow.AssetType.Bond) {
            nominalValue = IBondRead(_asset).getBondDetails().nominalValue;
        }

        for (uint256 index; index < _holders.length; ) {
            address holder = _holders[index];

            if (_isDistributionHolderPaid(_distributionID, holder)) {
                failedAddresses_[failedIndex] = holder;
                unchecked {
                    ++failedIndex;
                    ++index;
                }
                continue;
            }

            (bool success, uint256 amount) = (_assetType == ILifeCycleCashFlow.AssetType.Bond)
                ? _getCouponAmount(_asset, _distributionID, holder, nominalValue)
                : _getDividendAmount(_asset, _distributionID, holder);

            if (!success || !_payHolderDistribution(_distributionID, holder, amount, paymentToken)) {
                failedAddresses_[failedIndex] = holder;
                unchecked {
                    ++failedIndex;
                }
            } else {
                succeededAddresses_[succeededIndex] = holder;
                paidAmount_[succeededIndex] = amount;
                unchecked {
                    ++succeededIndex;
                }
            }

            unchecked {
                ++index;
            }
        }
        return (failedAddresses_, succeededAddresses_, paidAmount_);
    }

    /*
     * @dev Pay a snapshot to a list of holders
     *
     * @param asset The asset the snapshot belongs to
     * @param holders The holders to be paid
     * @param snapshotID The snapshot to be paid to the holders
     * @param amountOrPercentage The amount or percentage to be paid to the holders
     * @param getSnapshotAmount The function that calculates the amount to be paid to the holders
     *
     * @return The array of the holders addresses whose payment were not successful
     */
    function _paySnapshotHolders(
        address _asset,
        address[] memory _holders,
        uint256 _snapshotID,
        uint256 _amountOrPercentage,
        function(ILifeCycleCashFlow.SnapshotAmountInfo memory) internal returns (uint256) _getSnapshotAmount
    )
        private
        returns (address[] memory failedAddresses_, address[] memory succeededAddresses_, uint256[] memory paidAmount_)
    {
        failedAddresses_ = new address[](_holders.length);
        succeededAddresses_ = new address[](_holders.length);
        paidAmount_ = new uint256[](_holders.length);
        uint256 paymentTokenBalance = _lifeCycleCashFlowStorage().paymentToken.balanceOf(address(this));
        uint256 assetTotalSupply = _getTotalSupplyAtSnapshot(_asset, _snapshotID);

        uint256 failedIndex;
        uint256 succeededIndex;
        for (uint256 index; index < _holders.length; ) {
            address holder = _holders[index];
            if (_isSnapshotHolderPaid(_snapshotID, holder)) {
                failedAddresses_[failedIndex] = holder;
                unchecked {
                    ++failedIndex;
                    ++index;
                }
                continue;
            }

            ILifeCycleCashFlow.SnapshotAmountInfo memory amountInfo;
            amountInfo.asset = _asset;
            amountInfo.snapshotID = _snapshotID;
            amountInfo.holder = holder;
            amountInfo.amountOrPercentage = _amountOrPercentage;
            amountInfo.paymentTokenBalance = paymentTokenBalance;
            amountInfo.totalSupplyAtSnapshot = assetTotalSupply;
            uint256 amount = _getSnapshotAmount(amountInfo);

            if (!_paySnapshotHolder(_snapshotID, holder, amount, _lifeCycleCashFlowStorage().paymentToken)) {
                failedAddresses_[failedIndex] = holder;
                unchecked {
                    ++failedIndex;
                }
            } else {
                succeededAddresses_[succeededIndex] = holder;
                paidAmount_[succeededIndex] = amount;
                unchecked {
                    ++succeededIndex;
                }
            }

            unchecked {
                ++index;
            }
        }
        return (failedAddresses_, succeededAddresses_, paidAmount_);
    }

    /*
     * @dev Returns the array containing holders addresses who couldn't be paid for a cash out
     *
     * @param bond The bond the cash out belongs to
     * @param holders The holders to be paid
     *
     * @return The array of the holders addresses whose payment were not successful for the cash out
     */
    function _payHoldersCashOut(
        address _bond,
        address[] memory _holders
    )
        private
        returns (address[] memory failedAddresses_, address[] memory succeededAddresses_, uint256[] memory paidAmount_)
    {
        failedAddresses_ = new address[](_holders.length);
        succeededAddresses_ = new address[](_holders.length);
        paidAmount_ = new uint256[](_holders.length);
        OZ_IERC20 paymentToken = _lifeCycleCashFlowStorage().paymentToken;

        uint256 failedIndex;
        uint256 succeededIndex;
        for (uint256 index; index < _holders.length; ) {
            address holder = _holders[index];
            uint256 cashAmount = _getCashOutAmount(_bond, holder);

            if (!_payHolderCashOut(holder, cashAmount, paymentToken)) {
                failedAddresses_[failedIndex] = holder;
                unchecked {
                    ++failedIndex;
                }
            } else {
                uint256 tokensAmount = _getTokensAmount(_bond, holder);
                IBond(_bond).redeemAtMaturityByPartition(holder, _DEFAULT_PARTITION, tokensAmount);
                succeededAddresses_[succeededIndex] = holder;
                paidAmount_[succeededIndex] = cashAmount;
                unchecked {
                    ++succeededIndex;
                }
            }

            unchecked {
                ++index;
            }
        }
    }

    /*
     * @dev Pay an amount of USDC tokens to a holder
     *
     * @param distributionID The coupon/dividend identifier
     * @param holder The holder address to be paid
     * @param amount The amount of erc20 tokens to be paid to the holder
     * @paymentToken The payment token used to pay the distribution
     *
     * @return True if the payment succeeded, false otherwise
     */
    function _payHolderDistribution(
        uint256 _distributionID,
        address _holder,
        uint256 _amount,
        OZ_IERC20 _paymentToken
    ) private returns (bool) {
        if (_paymentToken.balanceOf(address(this)) < _amount) {
            return false;
        }

        if (_amount == 0) {
            _setDistributionHolderPaid(_distributionID, _holder);
            return true;
        }

        try _paymentToken.transfer(_holder, _amount) returns (bool result) {
            if (result) {
                _setDistributionHolderPaid(_distributionID, _holder);
            }
            return result;
        } catch {
            return false;
        }
    }

    /*
     * @dev Pay an amount of payment tokens to a holder
     *
     * @param snapshot The snapshot identifier
     * @param holder The holder address to be paid
     * @param amount The amount of erc20 tokens to be paid to the holder
     * @paymentToken The payment token used to pay the snapshot
     *
     * @return True if the payment succeeded, false otherwise
     */
    function _paySnapshotHolder(
        uint256 _snapshotID,
        address _holder,
        uint256 _amount,
        OZ_IERC20 _paymentToken
    ) private returns (bool) {
        if (_paymentToken.balanceOf(address(this)) < _amount) {
            return false;
        }

        if (_amount == 0) {
            _setSnapshotHolderPaid(_snapshotID, _holder);
            return true;
        }

        try _paymentToken.transfer(_holder, _amount) returns (bool result) {
            if (result) {
                _setSnapshotHolderPaid(_snapshotID, _holder);
            }
            return result;
        } catch {
            return false;
        }
    }

    /*
     * @dev Pay an amount of payment tokens to a holder
     *
     * @param holder The holder address to be paid
     * @param amount The amount of erc20 tokens to be paid to the holder
     * @paymentToken The payment token used to pay the cash out
     *
     * @return True if the payment succeeded, false otherwise
     */
    function _payHolderCashOut(address _holder, uint256 _amount, OZ_IERC20 _paymentToken) private returns (bool) {
        if (_paymentToken.balanceOf(address(this)) < _amount) {
            return false;
        }

        if (_amount == 0) {
            return true;
        }

        try _paymentToken.transfer(_holder, _amount) returns (bool result) {
            return result;
        } catch {
            return false;
        }
    }

    /*
     * @dev Get a list of holders of a coupon/dividend by page
     *
     * @param assetType The type of the asset, bond/equity, to get the holders
     * @param asset The asset the holders belongs to
     * @param distributionID The coupon/dividend identifier
     * @param pageIndex The index of the page
     * @param pageLength The number of holders
     *
     * @return The array of the holders addresses
     */
    function _getHolders(
        ILifeCycleCashFlow.AssetType _assetType,
        address _asset,
        uint256 _distributionID,
        uint256 _pageIndex,
        uint256 _pageLength
    ) private view returns (address[] memory holders_) {
        if (_assetType == ILifeCycleCashFlow.AssetType.Bond) {
            return IBondRead(_asset).getCouponHolders(_distributionID, _pageIndex, _pageLength);
        } else {
            return IEquity(_asset).getDividendHolders(_distributionID, _pageIndex, _pageLength);
        }
    }

    /*
     * @dev Get a list of holders of a snapshot
     *
     * @param asset The asset the snapshot belongs to
     * @param snapshotID The snapshot identifier
     * @param pageIndex The index of the page
     * @param pageLength The number of holders
     *
     * @return The array of the holders addresses
     */
    function _getHoldersBySnapshot(
        address _asset,
        uint256 _snapshotID,
        uint256 _pageIndex,
        uint256 _pageLength
    ) private view returns (address[] memory) {
        return ISnapshots(_asset).getTokenHoldersAtSnapshot(_snapshotID, _pageIndex, _pageLength);
    }

    /*
     * @dev Check that the contract manages a certain asset
     *
     * @param assetAddress The address of the asset to check
     */
    function _checkAsset(address _assetAddress) private view {
        if (_assetAddress != _lifeCycleCashFlowStorage().asset) {
            revert ILifeCycleCashFlow.InvalidAsset(_assetAddress);
        }
    }

    /*
     * @dev Check that today is the execution date of the distributionID
     *
     * @param asset The asset the distribution belongs to
     * @param distributionId The coupon or dividend identifier
     */
    function _checkDistributionDate(address _asset, uint256 _distributionID) private view {
        uint256 executionDateInit = _getDistributionExecutionDate(_asset, _distributionID);
        _checkPaymentDate(executionDateInit, _blockTimestamp());
    }

    /*
     * @dev Check that today is the maturity date of the bond
     *
     * @param bond The bond address
     */
    function _checkMaturityDate(address _bond) private view {
        uint256 maturityDateInit = IBondRead(_bond).getBondDetails().maturityDate;
        _checkPaymentDate(maturityDateInit, _blockTimestamp());
    }

    /*
     * @dev Get the amount of asset tokens of a holder
     *
     * @param asset The asset the holder's balance is requested
     * @param holder The holder whose tokens are requested
     *
     * @return The amount of tokens
     */
    function _getTokensAmount(address _asset, address _holder) private view returns (uint256) {
        return IERC1410(_asset).balanceOf(_holder);
    }

    /*
     * @dev Get the asset total supply
     *
     * @param asset The asset its total supply is requested
     *
     * @return The asset total supply
     */
    function _getTotalSupplyAtSnapshot(address _asset, uint256 _snapshotID) private view returns (uint256) {
        return ISnapshots(_asset).totalSupplyAtSnapshot(_snapshotID);
    }

    /*
     * @dev Get the coupon amount to pay for a certain holder
     *
     * @param asset The asset its coupon amount is requested
     * @param couponId The coupon identifier
     * @param holder The holder address to be paid
     * @param bondDetailsData Bond details to calculate the amount
     *
     * @return True if getting coupon for was successfully executed, false otherwise
     * @return The amount to be paid
     */
    function _getCouponAmount(
        address _asset,
        uint256 _couponID,
        address _holder,
        uint256 _nominalValue
    ) private view returns (bool success, uint256 amount) {
        try IBondRead(_asset).getCouponFor(_couponID, _holder) returns (IBondRead.CouponFor memory couponFor) {
            amount = ((couponFor.tokenBalance * _nominalValue * couponFor.period * couponFor.rate) /
                100 /
                (365 * 24 * 60 * 60) /
                10 ** couponFor.decimals /
                10 ** couponFor.rateDecimals);
            return (true, amount);
        } catch {
            return (false, 0);
        }
    }

    /*
     * @dev Get the dividend amount to pay for a certain holder
     *
     * @param asset The asset the dividend amount is requested
     * @param dividendID The dividend identifier
     * @param holder The holder address to be paid
     *
     * @return True if getting dividends for was successfully executed, false otherwise
     * @return The amount to be paid
     */
    function _getDividendAmount(
        address _asset,
        uint256 _dividendID,
        address _holder
    ) private view returns (bool success, uint256 amount) {
        IEquity equity = IEquity(_asset);
        try equity.getDividendsFor(_dividendID, _holder) returns (IEquity.DividendFor memory dividendFor) {
            amount = ((dividendFor.tokenBalance * dividendFor.amount) / 10 ** dividendFor.decimals);
            return (true, amount);
        } catch {
            return (false, 0);
        }
    }

    /*
     * @dev Get the cash out amount to pay for a certain holder
     *
     * @param asset The asset its cash out amount is requested
     * @param holder The holder address to be paid
     *
     * @return The amount to be paid
     */
    function _getCashOutAmount(address _asset, address _holder) private view returns (uint256) {
        IBondRead.BondDetailsData memory bondDetailsData = IBondRead(_asset).getBondDetails();
        uint8 bondDecimals = ERC20(_asset).getERC20Metadata().info.decimals;
        return ((IERC1410(_asset).balanceOf(_holder) * bondDetailsData.nominalValue) / 10 ** bondDecimals);
    }

    /*
     * @dev Get the coupon or dividend execution date
     *
     * @param asset The asset its distribution execution date is requested
     * @param distributionID The identifier of the coupon or dividend
     *
     * @returns The coupon or dividend execution date
     */
    function _getDistributionExecutionDate(address _asset, uint256 _distributionID) private view returns (uint256) {
        return
            (_lifeCycleCashFlowStorage().assetType == ILifeCycleCashFlow.AssetType.Bond)
                ? IBondRead(_asset).getCoupon(_distributionID).coupon.executionDate
                : IEquity(_asset).getDividends(_distributionID).dividend.executionDate;
    }

    /*
     * @dev Check that the payment token is valid
     *
     * @param paymentToken The payment token address
     */
    function _checkPaymentToken(address _paymentToken) private pure {
        if (_paymentToken == address(0)) {
            revert ILifeCycleCashFlow.InvalidPaymentToken(_paymentToken);
        }
    }

    /*
     * @dev Check that today is the payment date of a distribution or a bond
     *
     * @param initialDate The payment initialDate
     * @param currentDate The current date
     *
     * @returns True if the the current date is between the initial and the ending date
     * @returns The payment ending date
     */
    function _checkPaymentDate(uint256 _initialDate, uint256 _currentDate) private pure {
        if (_currentDate < _initialDate) {
            revert ILifeCycleCashFlow.NotPaymentDate(_initialDate, _currentDate);
        }
    }

    /*
     * @dev Filter zero address addresses from an array of holders
     *
     * @param holders The holder's array
     *
     * @returns The array of holder's addresses without zero address addresses
     */
    function _filterZeroAddresses(address[] memory holders) private pure returns (address[] memory) {
        uint256 count;

        for (uint256 i = 0; i < holders.length; i++) {
            if (holders[i] != address(0)) {
                count++;
            }
        }

        address[] memory filtered = new address[](count);

        uint256 index;
        for (uint256 i = 0; i < holders.length; i++) {
            if (holders[i] != address(0)) {
                filtered[index] = holders[i];
                index++;
            }
        }

        return filtered;
    }
}
