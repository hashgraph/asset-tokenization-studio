// SPDX-License-Identifier: Apache-2.0

/**
 * Generic contract registry wrapper factory.
 *
 * This module provides a reusable factory function for creating type-safe
 * registry helpers. Downstream projects can import this factory and provide
 * their own registry data generated by `generateRegistryPipeline`.
 *
 * @module infrastructure/registryFactory
 *
 * @example
 * ```typescript
 * // Step 1: Generate your registry data
 * import { generateRegistryPipeline } from '@hashgraph/asset-tokenization-contracts/scripts'
 *
 * const result = await generateRegistryPipeline({
 *     contractsPath: './contracts',
 *     outputPath: './generated/myRegistry.data.ts'
 * })
 *
 * // Step 2: Create helpers using the factory
 * import { createRegistryHelpers } from '@hashgraph/asset-tokenization-contracts/scripts'
 * import {
 *     FACET_REGISTRY,
 *     INFRASTRUCTURE_CONTRACTS,
 *     STORAGE_WRAPPER_REGISTRY
 * } from './generated/myRegistry.data'
 *
 * export const {
 *     getFacetDefinition,
 *     getAllFacets,
 *     hasFacet,
 *     getStorageWrapperDefinition,
 *     getAllStorageWrappers,
 * } = createRegistryHelpers(FACET_REGISTRY, INFRASTRUCTURE_CONTRACTS, STORAGE_WRAPPER_REGISTRY)
 * ```
 */

// IMPORTANT: Use relative imports for intra-layer dependencies
// Infrastructure files should import from each other using relative paths,
// NOT '@scripts/infrastructure', to avoid circular dependency issues.
// The @scripts/infrastructure alias points to index.ts, which exports from this file.
import type {
    FacetDefinition,
    ContractDefinition,
    StorageWrapperDefinition,
} from './types'

/**
 * Create registry helper functions for any contract registry.
 *
 * This factory function creates type-safe helper functions that can be used
 * to query a contract registry. It accepts facet, contract, and optionally
 * storage wrapper registries, and returns a set of helper functions.
 *
 * @template TFacetRegistry - Type of the facet registry
 * @template TContractRegistry - Type of the contract registry
 * @template TStorageWrapperRegistry - Type of the storage wrapper registry
 * @param facetRegistry - The facet registry object
 * @param contractRegistry - The contract registry object
 * @param storageWrapperRegistry - Optional storage wrapper registry object
 * @returns Object containing registry helper functions
 *
 * @example
 * ```typescript
 * import { createRegistryHelpers } from '@hashgraph/asset-tokenization-contracts/scripts'
 * import {
 *     FACET_REGISTRY,
 *     INFRASTRUCTURE_CONTRACTS,
 *     STORAGE_WRAPPER_REGISTRY
 * } from './registry.data'
 *
 * export const {
 *     getFacetDefinition,
 *     getContractDefinition,
 *     getAllFacets,
 *     getAllContracts,
 *     hasFacet,
 *     hasContract,
 *     getStorageWrapperDefinition,
 *     getAllStorageWrappers,
 *     hasStorageWrapper,
 *     FACET_REGISTRY_COUNT,
 * } = createRegistryHelpers(FACET_REGISTRY, INFRASTRUCTURE_CONTRACTS, STORAGE_WRAPPER_REGISTRY)
 * ```
 */
export function createRegistryHelpers<
    TFacetRegistry extends Record<string, FacetDefinition>,
    TContractRegistry extends Record<string, ContractDefinition>,
    TStorageWrapperRegistry extends Record<
        string,
        StorageWrapperDefinition
    > = Record<string, never>,
>(
    facetRegistry: TFacetRegistry,
    contractRegistry: TContractRegistry,
    storageWrapperRegistry?: TStorageWrapperRegistry
) {
    return {
        /**
         * Get facet definition by name.
         *
         * @param name - Facet name (e.g., 'AccessControlFacet')
         * @returns FacetDefinition if found, undefined otherwise
         */
        getFacetDefinition(name: string): FacetDefinition | undefined {
            return facetRegistry[name]
        },

        /**
         * Get contract definition by name.
         *
         * @param name - Contract name (e.g., 'BusinessLogicResolver')
         * @returns ContractDefinition if found, undefined otherwise
         */
        getContractDefinition(name: string): ContractDefinition | undefined {
            return contractRegistry[name]
        },

        /**
         * Get all facets.
         *
         * @returns Array of all FacetDefinitions
         */
        getAllFacets(): FacetDefinition[] {
            return Object.values(facetRegistry)
        },

        /**
         * Get all contracts.
         *
         * @returns Array of all ContractDefinitions
         */
        getAllContracts(): ContractDefinition[] {
            return Object.values(contractRegistry)
        },

        /**
         * Check if a facet exists in the registry.
         *
         * @param name - Facet name to check
         * @returns true if facet exists, false otherwise
         */
        hasFacet(name: string): boolean {
            return name in facetRegistry
        },

        /**
         * Check if a contract exists in the registry.
         *
         * @param name - Contract name to check
         * @returns true if contract exists, false otherwise
         */
        hasContract(name: string): boolean {
            return name in contractRegistry
        },

        /**
         * Total number of facets in the registry.
         */
        get FACET_REGISTRY_COUNT(): number {
            return Object.keys(facetRegistry).length
        },

        /**
         * Get storage wrapper definition by name.
         *
         * @param name - Storage wrapper name (e.g., 'AccessControlStorageWrapper')
         * @returns StorageWrapperDefinition if found, undefined otherwise
         */
        getStorageWrapperDefinition(
            name: string
        ): StorageWrapperDefinition | undefined {
            return storageWrapperRegistry?.[name]
        },

        /**
         * Get all storage wrappers.
         *
         * @returns Array of all StorageWrapperDefinitions
         */
        getAllStorageWrappers(): StorageWrapperDefinition[] {
            return storageWrapperRegistry
                ? Object.values(storageWrapperRegistry)
                : []
        },

        /**
         * Check if a storage wrapper exists in the registry.
         *
         * @param name - Storage wrapper name to check
         * @returns true if storage wrapper exists, false otherwise
         */
        hasStorageWrapper(name: string): boolean {
            return storageWrapperRegistry
                ? name in storageWrapperRegistry
                : false
        },

        /**
         * Total number of storage wrappers in the registry.
         */
        get STORAGE_WRAPPER_REGISTRY_COUNT(): number {
            return storageWrapperRegistry
                ? Object.keys(storageWrapperRegistry).length
                : 0
        },
    }
}
